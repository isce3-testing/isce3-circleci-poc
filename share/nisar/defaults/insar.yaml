runconfig:
    name: gunw_workflow_default

    groups:
        PGENameGroup:
            PGEName: INSAR_L_PGE

        InputFileGroup:
            # REQUIRED - One NISAR L1B RSLC formatted HDF5 file
            InputFilePath:

        DynamicAncillaryFileGroup:
            # REQUIRED - Use the provided DEM as input
            DEMFile:

        ProductPathGroup:
            # REQUIRED - Directory where PGE will place results. Irrelevant to SAS.
            ProductPath:

            # REQUIRED - Directory where SAS can write temporary data
            ScratchPath:

            # REQUIRED - SAS writes output product to the following file. PGE may rename.
            # NOTE: For R2 will need to handle mixed-mode case with multiple outputs of RSLC workflow.
            SASOutputFile:

        PrimaryExecutable:
            ProductType: GUNW

        DebugLevelGroup:
            DebugSwitch: false

        # TODO OPTIONAL - To setup type of worker
        worker:
            # OPTIONAL - To prevent downloading DEM / other data automatically. Default True
            internet_access: False

            # OPTIONAL - To explicitly use GPU capability if available. Default False
            gpu_enabled: False

            # Index of the GPU to use for processing, optional. Defaults to the
            # first available CUDA device. Ignored if *gpu_enabled* is False.
            gpu_id: 0

        # ADT section - isce3 + pyre workflow
        processing:
            input_subset:
                # Frequencies and polarisations to be processed
                list_of_frequencies:
                    # keys for frequency A and B are required.
                    # valid options for polarizations
                    # empty for all polarizations found in RSLC
                    # [polarizations] for list of specific frequency(s) e.g. [HH, HV] or [HH]
                    A:
                    B:

            # TODO OPTIONAL - Only checked when internet access is available
            dem_download:
                # OPTIONAL - s3 bucket / curl URL / local file
                source:
                top_left:
                    x:
                    y:
                bottom_right:
                    x:
                    y:

            # OPTIONAL - Mechanism to specify output posting and DEM
            geocode:
                # OPTIONAL - To control output grid in same units as output EPSG
                x_snap:

                # OPTIONAL - To control output grid in same units as output EPSG
                y_snap:

                # OPTIONAL - Same as input DEM if not provided.
                outputEPSG:

                # OPTIONAL - Spacing between pixels, in same units as output EPSG.
                # If not provided, spacing values will be taken from provided DEM.
                # All postings/spacings must be > 0.
                # ISCE3 output rasters always have North-up West-left orientation
                output_posting:
                    A:
                        x_posting:
                        y_posting:
                    B:
                        x_posting:
                        y_posting:

                # OPTIONAL - Can control with absolute values or with snap values
                top_left:
                    # OPTIONAL - Set top-left y in same units as output EPSG
                    y_abs:
                    # OPTIONAL - Set top-left x in same units as output EPSG
                    x_abs:

                # OPTIONAL - Can control with absolute values or with snap values
                bottom_right:
                    y_abs:
                    x_abs:

                # OPTIONAL - Set lines to be processed per block
                lines_per_block: 1000

            radar_grid_cubes:

                # List of heights in meters
                heights:

                # OPTIONAL - Same as the geocode group outputEPSG if not provided
                outputEPSG:

                # OPTIONAL - Spacing between pixels, in same units as output EPSG.
                # If not provided, spacing values will be taken from geocode group
                # parameters.
                # All postings/spacings must be > 0.
                # ISCE3 output rasters always have North-up West-left orientation
                output_posting:
                    x_posting:
                    y_posting:

                # OPTIONAL - To control output grid in same units as output EPSG
                y_snap:

                # OPTIONAL - To control output grid in same units as output EPSG
                x_snap:

                # OPTIONAL - Can control with absolute values or with snap values
                top_left:
                    # OPTIONAL - Set top-left y in same units as output EPSG
                    y_abs:
                    # OPTIONAL - Set top-left x in same units as output EPSG
                    x_abs:

                # OPTIONAL - Can control with absolute values or with snap values
                bottom_right:
                    y_abs:
                    x_abs:

            bandpass:
                # Number of lines per blocks
                lines_per_block: 1000
                # Set window function for range spectrum bandpass filtering
                window_function: tukey
                # Shape parameter. For Kaiser, 0 <= shape < Inf.
                # For Cosine and Tukey, 0 <= shape <= 1.
                window_shape: 0.25
                # FFT size in range.
                range_fft_size:

            geo2rdr:
                # No topo_path provided. Default to ScratchPath.
                threshold: 1.0e-8
                maxiter: 25
                lines_per_block: 1000

            rdr2geo:
                # No topo_path provided. Default to ScratchPath.
                threshold: 1.0e-7
                numiter: 25
                extraiter: 10
                lines_per_block: 1000

            dem_margin:

            coarse_resample:
                # Path to coarse offsets directory (geo2rdr offsets)
                offsets_dir:
                # Number of lines per tile to resample in batch
                lines_per_tile: 100

            dense_offsets:
                # Flag to enable/disable dense offsets estimation
                enabled: True
                # Path to HDF5 file or directory with geometry-coregistered SLCs.
                # Not required as we allow the use of intermediate outputs from
                # the previous InSAR module, which is not user-specified
                coregistered_slc_path:
                # Number of columns for chip/template window in reference image
                window_range: 64
                # Number of lines for chip/template window in reference image
                window_azimuth: 64
                # Number of columns for search chip/template in secondary image
                half_search_range: 20
                # Number of lines for search chip/template in secondary image
                half_search_azimuth: 20
                # Number of columns to skip in reference image for next offset estimate
                skip_range: 32
                # Number of lines to skip in reference image for next offset estimate
                skip_azimuth: 32
                # Margin around image edges to avoid for offset computation
                margin: 0
                # Number of columns of output offset (covariance, snr) file
                offset_width:
                # Number of lines of output offset (covariance, snr) file
                offset_length:
                # Start pixel of the reference image along slant range
                start_pixel_range:
                # Start pixel of the reference image along azimuth
                start_pixel_azimuth:
                # Domain (frequency or spatial) where to compute cross-correlation
                cross_correlation_domain: 'frequency'
                # Anti-aliasing oversampling factor to apply to reference/secondary SLC
                # prior to cross-correlation computation
                slc_oversampling_factor: 2
                # Deramp data prior to FFT: magnitude or complex (linear phase ramp)
                deramping_method: 'magnitude'
                # Flag to use constant range/azimuth offsets in dense offsets estimation
                use_gross_offsets: True
                # Constant offset along slant range to guide dense offset estimation
                gross_offset_range: 0
                # Constant gross offset along az to guide dense offset estimation
                gross_offset_azimuth: 0
                # File path to pixel by pixel gross offset (e.g. from reference velocity map)
                gross_offset_filepath:
                # Flag to add gross offset to the output of dense offset file
                merge_gross_offset:
                # Square zoom window size for cross-correlation statistics (SNR, covariance)
                correlation_statistics_zoom: 21
                # Square zoom window size for sub-pixel offset refinement
                correlation_surface_zoom: 8
                # Oversampling factor of the correlation surface for sub-pixel offset refinement
                correlation_surface_oversampling_factor: 64
                # Correlation surface oversampling algorithm
                correlation_surface_oversampling_method: 'sinc'
                # Number of cuda streams
                cuda_streams:
                # Number of offset estimates to process in batch along slant range
                windows_batch_range: 10
                # Number of offset estimates to process in batch along azimuth
                windows_batch_azimuth: 1

            rubbersheet:
                # Path to dense offsets outputs (offsets, snr, covariance).
                # Not required as InSAR workflow allows using intermediate outputs
                # from previous steps (not user-specified)
                dense_offsets_path:
                # Path to geo2rdr offsets
                geo2rdr_offsets_path:
                # Flag to enable/disable rubbersheet step
                enabled: True
                # Metric used to identify offsets outliers
                culling_metric: median_filter
                # Size of median and moving average filter in range. Median filter is used
                # for offset outlier identification. Moving average is used to smooth the
                # culled offset field prior to interferogram formation
                median_filter_size_range: 9
                # Size of median and moving average filter in azimuth (see above)
                median_filter_size_azimuth: 9
                # Threshold for outlier identification. Depends on "culling_metric".
                # SNR: offsets with SNR below threshold are identified as outliers
                # Covariance: offsets with range/azimuth covariance above threshold are outliers
                # Median filter: offsets with median absolute deviation above thresholds are outliers
                threshold: 0.5
                # Flag to enable mask refinement The intent of this refinement is to remove
                # noisy spots on 1-2 pixels after the first outlier identification.
                # The refinement is performed by thresholding the median absolute deviation of
                # the offsets where outlier locations have been filled with zeros
                mask_refine_enabled: True
                # Threshold for outlier refinement mask computation
                mask_refine_threshold: 0.5
                # Size of median filter in range and azimuth for outlier mask refinement
                mask_refine_filter_size: 3
                # Method to fill data holes left by outliers culling:
                # fill_smoothed: iteratively fill holes with mean value in a neighborhood.
                # nearest_neighbor: Fill holes with nearest neighbor interpolation
                outlier_filling_method: fill_smoothed
                fill_smoothed:
                    # Number of fill smoothed iterations
                    iterations: 1
                    # Size of the neighborhood to look for smoothed values
                    kernel_size: 3
                # Interpolation method. Interpolation is used to fill residual outlier
                # holes if present
                interpolation_method: linear
                # It is good practice to filter the offsets prior to interferogram
                # formation to reduce noise. We expose: no_filter: do not filter the offsets/
                # degrade offsets resolution. median_filter, boxcar_filter (moving average),
                # gaussian_filter
                offsets_filter: boxcar
                boxcar:
                    # Filter size (median/boxcar) in slant range
                    filter_size_range: 5
                    filter_size_azimuth: 5

            fine_resample:
                # Flag to enable/disable fine resampling
                enabled: True
                # Path to fine offsets (rubbersheet dense offsets)
                offsets_dir:
                # Number of lines per tile to resample in batch
                lines_per_tile: 100

            crossmul:
                range_looks: 11
                azimuth_looks: 11
                flatten: True
                oversample: 2
                rows_per_block: 8192


            filter_interferogram:
                interferogram_path:
                mask:
                    general:
                lines_per_block: 100
                filter_type: boxcar
                boxcar:
                    filter_size_range: 9
                    filter_size_azimuth: 9

            phase_unwrap:
                # Path to HDF5 file or directory containing the input interferogram
                # and coherence (normalized magnitude of complex correlation) rasters
                # Not required as we allow the use of intermediate outputs from
                # the previous InSAR module, which is not user-specified.
                # Required for running stand-alone phase unwrapping
                crossmul_path:
                # Increments to correlation threshold
                correlation_threshold_increments: 0.1
                # Unwrapping algorithm to use
                algorithm: icu
